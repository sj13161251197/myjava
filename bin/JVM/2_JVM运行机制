jvm启动流程
	1.Java 启动类名称xxx(这个类有main方法)
	2.jvm在当前路径寻找配置文件jvm.config
	3.定位jvm.dll（初始化虚拟机，获取相关接口JNIEnv，findClass等） 
	4.找到main方法  进行解析执行
	
JVM内部结构
	Class文件 被classLoad加载到内存空间根据class中的不同内容加载到不同的区域
	区域：方法区：类型的常量池，字段，方法信息，方法字节码，一般都是类的原信息对类进行描述
		永久区（perm）
		java堆:系统的new的具体对象，全局共享
			堆的结构和gc的算法相关如分代GC
		java栈：线程私有，栈由一系列帧组成，先进后出的数据结构  内容（方法调用时局部变量、操作数栈、常量池指针）
				每一次方法调用创建一个帧，并压栈
				普通方法比静态方法多传一个参数this
		本地方法区
	每个线程启动：先分配一个pc寄存器（指定下一条命令的地址，执行本地时为未定义）	
	
在栈上分配的要求与好处:
	
	小对象（一般几十个bytes），在没有逃逸的情况下，可以直接分配在栈上
	直接分配在栈上，可以自动回收，减轻GC压力
	大对象或者逃逸对象无法栈上分配
	逃逸：所分配的对象除了在这个线程上使用还在别的线程上使用了，因为栈时线程私有的
	
堆栈方法区的调用关系---
	main方法入栈   new App(),
	在堆分配空间  app.test()  
	栈找堆要实列  
	堆找方法区  实列到方法区找方法的字节码	

JVM的内存关系
	每一个线程都有一个工作内存（线程私有）和主存（共享）
	主存和工作内存为了数据同步如何做呢：
	当数据从主内存复制到工作存储时，必须出现两个动作：
		第一，由主内存执行的读（read）操作；
		第二，由工作内存执行的相应的load操作；
	当数据从工作内存拷贝到主内存时，也出现两个操作：
		第一个，由工作内存执行的存储（store）操作；
		第二，由主内存执行的相应的写（write）操作
	由于read和load属于2个操作中间有间隔或者中断导致2个线程用一个数据时数据不同步
	因为线程操作数据默认是操作工作内存的
	
	
	
	解释：高速缓存-线程工作内存
		算机在执行程序时，每条指令都是在CPU中执行的，
		而执行指令过程中，势必涉及到数据的读取和写入。
		由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，
		这时就存在一个问题，由于CPU执行速度很快，
		而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，
		因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。
		因此在CPU里面就有了高速缓存。
	
	.volatile关键字的两层语义

　　一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：

　　	1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
	
　　	2）禁止进行指令重排序。

	第一：使用volatile关键字会强制将修改的值立即写入主存；

　　	第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；

	第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。
		