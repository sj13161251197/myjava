Garbage Collection 垃圾收集

Java中，GC的对象是堆空间和永久区
引用计数法
标记清除
标记压缩
复制算法
java使用分代处理gc
	短命对象归为新生代，长命对象归为老年代。
		根据不同代的特点，选取合适的收集算法
		少量对象存活，适合复制算法
		大量对象存活，适合标记清理或者标记压缩
怎么就算是GC认为的垃圾对象呢
	可触及的
		从根节点可以触及到这个对象：（一般认为线程栈上的对象为根对象，全区对象和常量对象）
	可复活的
		一旦所有引用被释放，就是可复活状态，因为在finalize()中可能复活该对象
	不可触及的
		在finalize()后，可能会进入不可触及状态，不可触及的对象不可能复活
	可以回收
		
finalize方法的使用：gc调用之前调用（线程优先低，并且重写容易导致gc不可达可复活（））	


Stop-The-World
	Java中一种全局暂停的现象
	全局停顿，所有Java代码停止，native代码可以执行，但不能和JVM交互
	多半由于GC引起：大量gc要处理的回收对象需要大量内存  jvm没有办法短时间处理完成，由于gc线程时别的线程都要停下啦
		新生代的GC 快
		老年代的gc 大切慢
	Dump线程
	死锁检查
	堆Dump

jvm中具体的gc使用
	串行收集器：一个串行收集器线程  管理应用程序多个线程   收集器启动应用暂停
		新生代、老年代使用串行回收
		新生代复制算法
		老年代标记-压缩
	ParNew并行收集器：
		新生代并行
		老年代串行
	Parallel收集器
		类似ParNew
		新生代复制算法
		老年代 标记-压缩
		更加关注吞吐量
	CMS收集器
		Concurrent Mark Sweep 并发标记清除
		标记-清除算法
		与标记-压缩相比
		并发阶段会降低吞吐量
		老年代收集器（新生代使用ParNew）
		-XX:+UseConcMarkSweepGC
	
		
	
	
